---
description: AI agent-friendly API design principles and mandatory backend test coverage
alwaysApply: true
---

# AI Agent-Friendly System Design

This system is **AI agent-driven**. Every API surface must be designed so that an AI agent (e.g., OpenClaw, LLM tool-use, MCP client) can discover, call, and interpret endpoints **without human assistance**.

---

## 1. Structured, Machine-Parseable Responses

- Every endpoint MUST return JSON with typed Pydantic `response_model`.
- Webhook responses use the standard envelope: `{"success": bool, "message": str, "data": dict}`.
- The only exception is `GET /summary` which returns plain text for quick LLM consumption.

```python
# ✅ GOOD — typed response model
@router.get("/stocks", response_model=list[StockResponse])
def list_stocks(): ...

# ❌ BAD — untyped dict
@router.get("/stocks")
def list_stocks():
    return {"stocks": [...]}
```

## 2. Descriptive Error Responses

- All errors MUST return a JSON body with both `detail` (human-readable) and `error_code` (machine-readable slug).
- Agents branch on `error_code`, not on substring matching `detail`.

```python
# ✅ GOOD
raise HTTPException(status_code=404, detail={
    "error_code": "STOCK_NOT_FOUND",
    "detail": "找不到股票 NVDA。"
})

# ❌ BAD — bare string detail
raise HTTPException(status_code=404, detail="找不到股票 NVDA。")
```

## 3. Webhook Action Discoverability

- `POST /webhook` with `{"action": "help"}` MUST return the list of all supported actions, their required parameters, and descriptions.
- This lets agents self-discover capabilities at runtime without reading docs.
- Keep the action registry in a single dict/enum in `backend/domain/constants.py`.

## 4. OpenAPI Completeness

Every FastAPI route MUST have:
1. A `summary` parameter in the decorator (shown in Swagger & OpenAPI JSON).
2. A typed `response_model`.
3. Pydantic request body schemas for POST/PUT/PATCH.

This ensures `/openapi.json` is a complete, self-describing contract that any agent can consume.

```python
# ✅ GOOD — fully described
@router.post("/ticker", response_model=StockResponse, summary="Add a stock to the watchlist")
def create_stock(req: TickerCreateRequest): ...

# ❌ BAD — missing summary and response_model
@router.post("/ticker")
def create_stock(req: dict): ...
```

## 5. Idempotent & Safe Operations

- GET endpoints MUST be safe (no side effects).
- POST/PUT endpoints SHOULD be idempotent where possible. Document idempotency behavior in the function docstring.

## 6. Pagination & Filtering

- List endpoints (`GET /stocks`, `GET /holdings`, `GET /scan/history`) SHOULD support `limit` and `offset` query params.
- Default: `limit=50`, `offset=0`. Agents can paginate large datasets.

## 7. Consistent Datetime Format

- All timestamps in JSON responses MUST be ISO 8601 UTC strings (e.g., `"2025-12-01T08:30:00Z"`).

## 8. Rate-Limit Headers

- Include `X-RateLimit-Remaining` and `X-RateLimit-Reset` response headers so agents can self-throttle without trial-and-error.

## 9. Versioning Readiness

- The webhook action registry lives in `backend/domain/constants.py` as a single source of truth.
- Adding a new agent action = one dict entry + one handler function. No scattering across files.

---

# Backend Testing Standards (pytest)

Every feature MUST ship with tests. No untested code in production.

## Test File Structure

Tests live in `backend/tests/` mirroring the source layout:

```
backend/tests/
├── conftest.py              # Shared fixtures (TestClient, in-memory DB, mocks)
├── api/
│   ├── test_stock_routes.py
│   ├── test_thesis_routes.py
│   ├── test_scan_routes.py
│   ├── test_holding_routes.py
│   ├── test_persona_routes.py
│   └── test_telegram_routes.py
├── application/
│   └── test_services.py
├── domain/
│   ├── test_analysis.py
│   └── test_rebalance.py
└── infrastructure/
    └── test_repositories.py
```

## Test Naming

Use descriptive names: `test_<function>_should_<expected_behavior>`

```python
# ✅ GOOD
def test_create_stock_should_return_409_when_duplicate(): ...
def test_webhook_signals_should_return_rsi_and_ma(): ...

# ❌ BAD
def test_stock(): ...
def test_1(): ...
```

## AAA Pattern

Every test follows **Arrange / Act / Assert**:

```python
def test_deactivate_stock_should_record_reason():
    # Arrange
    client.post("/ticker", json={"ticker": "NVDA", "category": "Growth", "thesis": "AI leader"})

    # Act
    resp = client.post("/ticker/NVDA/deactivate", json={"reason": "Valuation too high"})

    # Assert
    assert resp.status_code == 200
    assert "NVDA" in resp.json()["message"]
```

## Fixtures & conftest.py

- `conftest.py` provides: `TestClient`, in-memory SQLite DB, mock yfinance data, mock Telegram sender.
- Use `@pytest.fixture` with appropriate scope (`session` for DB, `function` for per-test isolation).

## Mock External Services

- **yfinance**, **Telegram Bot API**, and any network I/O MUST be mocked. Never hit real APIs in tests.
- Use `unittest.mock.patch` or `pytest-mock` to replace infrastructure adapters.

## Minimum Test Coverage Per Endpoint

| Scenario | Status Code |
|----------|-------------|
| Happy path | 200 / 201 |
| Validation error | 422 |
| Not found | 404 |
| Conflict / duplicate | 409 (where applicable) |

## Webhook Action Coverage

- Every webhook action MUST have at least **one happy-path test** and **one error-path test**.
- The `help` action must be tested to ensure discoverability stays accurate.

## Mandatory Coverage Rule

- Every new feature or bug fix MUST include corresponding tests.
- PRs that change business logic without adding or updating tests should be flagged during review.

---

# Agent Skill & Documentation Sync

Every code change that affects the API surface MUST update the agent skill files so AI agents always have an accurate understanding of the system.

## Files to Update

| File | What to update |
|------|----------------|
| `scripts/openclaw/folio/SKILL.md` | Webhook actions table, direct API endpoint table, categories, response format, usage tips |
| `scripts/openclaw/AGENTS.md` | Key endpoints list, webhook actions table, direct API table, response guidelines |

## When to Update

- **New endpoint added** -- Add it to the direct API table in both files.
- **New webhook action added** -- Add it to the webhook actions table with description, required params, and example.
- **Endpoint removed or renamed** -- Remove/update the old entry in both files.
- **Request/response schema changed** -- Update the example payloads and response format sections.
- **New category or enum value added** -- Update the categories table.
- **Error codes changed** -- Update any documented error handling examples.

## Rules

- Skill files are the **primary interface** between AI agents and this system. Treat them as a first-class API contract, not an afterthought.
- Keep descriptions concise and action-oriented -- agents need to know **what to call** and **what to expect back**, not implementation details.
- Always include a concrete `curl` or JSON example for new webhook actions.
- The `POST /webhook {"action": "help"}` response and the skill files MUST stay in sync. If they diverge, agents will make incorrect calls.
